# Summer_Internship



Week No : 1

Day 1: Introduction and Setup
• Objective: Orientation and initial setup for the project.
• Activities:
o Participated in an online orientation session to learn about the
company's mission, values, and internship program specifics.
o Held a virtual meeting with my project mentor to discuss the
objectives and requirements for the calculator app.
o Set up my development environment by installing the Flutter SDK
and Android Studio.
o Reviewed Flutter documentation and explored sample projects to
gain a foundational understanding of Flutter development.

• Outcome:
o Acquired a comprehensive understanding of the company and
project goals.
o Development environment successfully set up and ready for use.

Day 2: Project Planning and Initial Steps
• Objective: Plan the project and take the first steps towards development.
• Activities:
o Defined the scope of the app, which includes basic arithmetic
operations: addition, subtraction, multiplication, and division.
o Sketched a simple and user-friendly design for the calculator
interface.
o Created a new Flutter project and set up the basic project structure,
including the main.dart file.

• Outcome:
o Clear project plan and design layout established.
o Initial project setup completed, laying the groundwork for
development.

Day 3: Building the User Interface
• Objective: Design and implement the user interface (UI) of the calculator
app.
• Activities:
o Implemented the UI using Flutter widgets such as Container, Row,
Column, and Buttons.
o Designed and added buttons for digits (0-9), arithmetic operations
(+, -, *, /), and necessary functions like clear (C) and equals (=).
o Tested the app on an emulator to ensure proper alignment and
spacing, making adjustments to refine the UI.

• Outcome:
o User interface designed and implemented.
o UI components tested and adjusted for proper functionality and
appearance.

Day 4: Implementing Functionality
• Objective: Add functionality to the calculator app.
• Activities:
o Learned about state management in Flutter and used setState to
manage the app's state.
o Added onPressed events to buttons to capture user input and display
it on the screen.
o Implemented logic to handle and display the current input and
results using a Text widget.

• Outcome:
o Basic functionality integrated, allowing user interaction and input
display.
o State management set up to handle real-time updates.

Day 5: Arithmetic Operations and Final Testing
• Objective: Implement arithmetic operations and conduct final testing.
• Activities:
o Captured and stored input values and operations in variables.
o Implemented the logic for performing arithmetic operations and
updating the display accordingly.
o Tested the operations to ensure they worked correctly and handled
both valid and invalid inputs appropriately.
o Reviewed and refactored the code to improve readability and
efficiency.
o Documented the code and created a brief user guide on how to use
the app.
• Outcome:
o Core arithmetic operations successfully implemented and tested.
o Code reviewed, refactored, and documented.
o User guide created for app usage.



Week No : 2

Day 1: Project Setup and Data Modeling
This week started with setting up a new Flutter project specifically for the to-do list app. I
defined a data model class to represent individual tasks, including details like description,
completion status, and potentially priority level. I also explored different state management
solutions like Provider and BLoC to handle the app's state effectively.

Day 2: Designing the User Interface
On the second day, the focus shifted towards designing a user-friendly interface. I sketched
layouts for adding new tasks, displaying existing ones, and marking them complete. These
layouts were then implemented using Flutter widgets like ListView, TextFields, Checkboxes,
and Buttons.

Day 3: Implementing Task Addition Functionality
On the third day, I delved into implementing functionalities for adding new tasks. This
included creating a user input field for entering task descriptions and a button to add the task to
the list. The chosen state management solution played a crucial role in managing the list of
tasks within the app's state.

Day 4: Displaying and Managing Tasks
The focus on the fourth day was on displaying the to-do list effectively within the UI. This
involved iterating through the task list stored in the app's state and displaying them using
widgets like ListView and Text. I also implemented functionality to mark tasks as complete by
updating their completion status within the data model and refreshing the UI accordingly.

Day 5: Final Touches and Testing
On the fifth day, I concentrated on polishing the app and conducting thorough testing. I made
sure all functionalities worked smoothly and the UI was intuitive. I also fixed any bugs that
popped up during testing and ensured that marking tasks as complete updated the UI as
expected.



Week No : 3

Day 1: Project Setup and Initial Planning
The week began with setting up the new Flutter project for the stopwatch app. I defined the
basic requirements and functionalities, such as starting, pausing, resetting the timer, and
recording lap times. I also installed necessary dependencies and explored various Flutter
widgets and libraries that could be useful for this project.

Day 2: Designing the User Interface
On the second day, I focused on designing a clean and intuitive user interface. I sketched a
layout that included a large display for the timer, buttons for starting/pausing, resetting, and
recording lap times. I then started implementing this design using Flutter's Material
components, ensuring the UI was responsive and user-friendly.

Day 3: Implementing Core Stopwatch Functionality
The third day was dedicated to implementing the core functionality of the stopwatch. I used
Flutter's Timer class to create a periodic timer that updates every 10 milliseconds. I
implemented the logic to start, pause, and reset the timer. Additionally, I added a button that
toggles between start and pause states.

Day 4: Adding Lap Time Feature
On the fourth day, I focused on adding the lap time feature. I implemented functionality to
record the current time when the user presses the "Lap Time" button and display these lap
times in a list below the main timer display. I ensured that lap times were accurately recorded
and displayed in reverse chronological order.

Day 5: Final Touches and Testing
The final day was spent on polishing the app and conducting thorough testing. I fixed any bugs
that were discovered during testing and made sure the UI elements were properly aligned and
functional. I also tested the app's performance to ensure it ran smoothly without any lag or
crashes.



Week No : 4

Day 1: Project Setup and Initial Planning
The week began with setting up a dedicated Flutter project for the Tic Tac Toe game. We
outlined the core functionalities, including the game board setup, player turns, win condition
checks, and game reset functionality.

Day 2: Designing the User Interface
The focus shifted towards designing an engaging and intuitive user interface. We created sketches
for the game board, player indicators, and buttons for resetting the game. These designs were then
implemented using Flutter widgets, such as GridView for the game board and Text for displaying
player turns and game status.

Day 3: Implementing Game Logic
This day was dedicated to coding the core game logic. We implemented the functionality to
handle player moves, switch turns between players, and check for win conditions (rows, columns,
and diagonals). Additionally, we added logic to detect draw conditions when the board is full.

Day 4: Enhancing User Experience and Visual Feedback
The focus was on providing clear visual feedback and improving the overall user experience. We
added features such as highlighting the winning line and displaying appropriate messages for win,
draw, and ongoing game states. We also refined the UI elements for better aesthetics and
usability.

Day 5: Testing, Debugging, and Final Refinements
The final day was dedicated to extensive testing and debugging. We tested the game thoroughly
to ensure all functionalities worked as expected, including detecting win and draw conditions
accurately. Based on the testing results, we identified and fixed any bugs. Additionally, we made
final refinements to the user interface to ensure a polished and user-friendly experience.
